#include <array>      // std::array
#include <cstdint>    // uint32_t, int32_t
#include <cstring>    // std::memcpy, std::strlen
#include <iostream>   // std::cout
#include <vector>     // std::vector

#include <arpa/inet.h>  // ntohs(), ntohl()
#include <errno.h>      // errno
#include <netinet/ip.h> // sockaddr_in
#include <sys/socket.h> // socket(), setsockopt(), bind(), listen(), accept()
#include <unistd.h>     // close(), read(), write()
#include <poll.h>       // poll()
#include <assert.h>     // assert()
#include <fcntl.h>      // F_GETFL, F_SETFL, O_NONBLOCK

constexpr size_t LEN_FIELD_SIZE{ 4 };
constexpr size_t MAX_MSG_FIELD_SIZE{ 32 << 20 };
#include <vector>     // std::vector
// ============================= Socket Handling =============================
int create_server_socket()
{
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
        std::cout << "Failed to create socket. errno: " << errno << "\n";

    return server_fd;
}

void set_socket_options(int server_fd)
{
    int val = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
}

void bind_socket(int server_fd)
{
    struct sockaddr_in addr {};
    addr.sin_family = AF_INET;
    addr.sin_port = ntohs(1234);
    addr.sin_addr.s_addr = ntohl(0);

    if (bind(server_fd, (const sockaddr*)&addr, sizeof(addr)) == -1)
        std::cout << "Failed to bind a sockaddr to server_fd\n";
}

int accept_connection(int server_fd)
{
    struct sockaddr_in client_addr {};
    socklen_t socklen{ sizeof(client_addr) };
    int connfd = accept(server_fd, (struct sockaddr*)&client_addr, &socklen);
    if (connfd == -1)
        std::cout << "Connection failed with client addr\n";
    return connfd;
}

void set_nonblocking(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1)
        std::cout << "Failed to get fcntl()\n"; return;

    flags |= O_NONBLOCK;

    if (fcntl(fd, F_SETFL, flags) == -1)
        std::cout << "Failed to get fcntl()\n";
}

// ============================= Event Loop =============================
struct Conn {
    int fd = -1;
    // application's intention, for the event loop
    bool want_read = false;
    bool want_write = false;
    bool want_close = false;
    // buffered input and output
    std::vector<uint8_t> incoming;  // data to be parsed by the application
    std::vector<uint8_t> outgoing;  // responses generated by the application
};

void buf_append(std::vector<uint8_t>& buf, const uint8_t* data, size_t len) {
    buf.insert(buf.end(), data, data + len);
}

// remove from the front
void buf_consume(std::vector<uint8_t>& buf, size_t n) {
    buf.erase(buf.begin(), buf.begin() + n);
}

Conn* handle_accept(int fd)
{
    struct sockaddr_in client_addr {};
    socklen_t socklen{ sizeof(client_addr) };
    int connfd = accept(fd, (struct sockaddr*)&client_addr, &socklen);
    if (connfd == -1)
    {
        std::cout << "Connection failed with client addr\n";
        return nullptr;
    }
    uint32_t ip = client_addr.sin_addr.s_addr;
    printf("new client from %u.%u.%u.%u:%u\n",
        ip & 255, (ip >> 8) & 255, (ip >> 16) & 255, ip >> 24,
        ntohs(client_addr.sin_port)
    );

    set_nonblocking(connfd); // set new conn as nonblocking
    return new Conn{ connfd, true, false, false };  // set want_read to true 
}

bool try_one_request(Conn* conn)
{
    // 3. Try to parse the accumulated buffer
    if (conn->incoming.size() < LEN_FIELD_SIZE) return false;
    uint32_t data_len{};
    memcpy(&data_len, conn->incoming.data(), LEN_FIELD_SIZE);
    if (data_len > MAX_MSG_FIELD_SIZE)
    {
        std::cout << "too long\n";
        conn->want_close = true;
        return false;
    }

    // want to read
    if (LEN_FIELD_SIZE + data_len > conn->incoming.size()) return false;

    const uint8_t* payload = &conn->incoming[LEN_FIELD_SIZE];

    // 4. Process the parsed message
    printf("client says: len:%d data:%.*s\n",
        data_len, (data_len < 100) ? data_len : 100, payload);

    // insert length + payload
    buf_append(conn->outgoing, (const uint8_t*)&data_len, LEN_FIELD_SIZE);
    buf_append(conn->outgoing, payload, data_len);

    // remove from front
    buf_consume(conn->incoming, LEN_FIELD_SIZE + data_len);

    return true;
}

void handle_write(Conn* conn)
{
    assert(conn->outgoing.size() > 0);
    ssize_t rv = write(conn->fd, &conn->outgoing[0], conn->outgoing.size());

    if (rv < 0)
    {
        std::cout << "write() error\n";
        conn->want_close = true;
        return;
    }

    buf_consume(conn->outgoing, (size_t)rv);

    if (conn->outgoing.size() == 0) {
        conn->want_read = true;
        conn->want_write = false;
    }
}

void handle_read(Conn* conn)
{
    // 1. Do a non-blocking read.
    uint8_t buf[64 * 1024]; // 64 kb
    ssize_t rv = read(conn->fd, buf, sizeof(buf));

    // If syscall fails && no data available to read
    if (rv < 0 && errno == EAGAIN) return;

    // If syscall fails
    if (rv < 0)
    {
        std::cout << "read() error\n";
        conn->want_close = true;
        return;
    }

    // EOF reached
    if (rv == 0)
    {
        if (conn->incoming.size() == 0)
            std::cout << "client closed\n";
        else
            std::cout << "unexpected EOF\n";

        conn->want_close = true;
        return;
    }

    // 2. Add new data to the `Conn::incoming` buffer
    buf_append(conn->incoming, buf, (size_t)rv);

    // parse requests and generate responses
    while (try_one_request(conn)) {}

    // 5. Remove the message from `Conn::incoming`
    if (conn->outgoing.size() > 0)
    {
        conn->want_read = false;
        conn->want_write = true;
        // Socket is likely ready to write in a request-response protocol,
        // Try to write from socket right away
        handle_write(conn);
    }
}

int main()
{
    int server_fd = create_server_socket();
    set_socket_options(server_fd);
    bind_socket(server_fd);
    // ensure syscalls like read and write return immediately 
    set_nonblocking(server_fd);
    listen(server_fd, SOMAXCONN);

    // a map of all client connections, keyed by fd
    std::vector<Conn*> fd2conn{};

    // the event loop
    std::vector<struct pollfd> poll_args{};

    while (true)
    {
        poll_args.clear();

        // Add the server fd
        struct pollfd pfd = { server_fd, POLLIN, 0 };
        poll_args.push_back(pfd);

        // Add the client fds
        for (auto& conn : fd2conn)
        {
            if (!conn)
                continue;

            struct pollfd pfd = { conn->fd, POLLERR, 0 };
            if (conn->want_read)
                pfd.events |= POLLIN;
            if (conn->want_write)
                pfd.events |= POLLOUT;

            poll_args.push_back(pfd);
        }

        // Now we have poll_args populated
        // Blocks until at least one fd is ready for IO event
        int rv = poll(poll_args.data(), poll_args.size(), -1);
        if (rv < 0 && errno == EINTR) continue;
        if (rv < 0) abort();

        // add new connection to server_fd
        if (poll_args[0].revents)
        {
            auto* conn = handle_accept(server_fd);
            // Insert into fd2conn, resize if required
            if (conn)
            {
                if (fd2conn.size() <= conn->fd)
                    fd2conn.resize(conn->fd + 1);

                assert(!fd2conn.at(conn->fd));
                fd2conn[conn->fd] = conn;
            }
        }

        // Skip the listening socket and handle the connection sockets
        for (size_t i = 1; i < poll_args.size(); i++)
        {
            auto ready = poll_args[i].revents;
            if (!ready) continue;

            auto* conn = fd2conn[poll_args[i].fd];
            if (ready & POLLIN)
            {
                assert(conn->want_read);
                handle_read(conn);
            }
            if (ready & POLLOUT)
            {
                assert(conn->want_write);
                handle_write(conn);
            }

            // close the socket from socket error or application logic
            if ((ready & POLLERR) || conn->want_close) {
                (void)close(conn->fd);
                fd2conn[conn->fd] = NULL;
                delete conn;
            }
        }
    }
    return 0;
}